# 第九周课程笔记

**学习是不可能速成的。学习是一件“逆人性”的事，就像锻炼身体一样，需要人持续付出，会让人感到痛苦，并随时想找理由放弃。**



## 数据库原理与性能优化

### 数据库架构

- 连接器：为每个请求分配一块专用的内存空间用于会话上下文。应用启动时通常会创建一个连接池用于加速数据库连接。

- 语法分析器：检测 SQL 语法是否正确

- 语义分析与优化：将常见的复杂嵌套语句转化成更高效的索引语句，但是种类比较有限吧

- 执行引擎：生成执行计划，可以用`explain`查看执行计划包含的信息，一般包括 Id、type、key，rows 等等信息。

  MySQL 可以分为 Server 层和存储引擎层两部分。

  Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

  而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

  ![1605924469283](https://github.com/hwangyungping/TalkGo/blob/master/架构师训练营-第一期/images/1605924469283.png)

![1605924469283](.\images\1605924469283.png)



### 索引

在几百万行的数据库里查找记录，需要全表扫描，效率很低。我们可以选择建索引提速。索引事实上就是创建一个 B+ 树（上文数据结构篇里提到了），在 `O(log n)` 时间内找到节点。

### 事务

- 原子性（Atomicity）：每个事务内部所有操作要么全部完成，要么全部不完成
- 一致性（Consistency ）：任何事务都使数据库从一个有效的状态转换到另一个有效状态
- 隔离性（Isolation）：并发执行事务的结果与顺序执行事务的结果相同
- 持久性（Durability ）：事务提交后，对系统的影响是永久的

### 日志

| MySql 日志类型                    | 解析说明                                                   |
| --------------------------------- | ---------------------------------------------------------- |
| 错误日志（error log）             | 当数据库启动、运行、停止时产生该日志                       |
| 普通查询日志（general query log） | 客户端连接数据库执行语句时产生该日志                       |
| 二进制日志（binary log）          | 当数据库内容发生改变时产生该日志，也被用来实现主从复制功能 |
| 中继日志（relay log）             | 从库上收到主库的数据更新时产生该日志                       |
| 慢查询日志（show query log）      | SQL 语句在数据库查询超过指定时间时产生该日志               |
| DDL 日志（metadata log）          | 执行 DDL 语句操作元数据时产生该日志                        |



## JVM

JVM（java 虚拟机）就是一层用软件实现的物理机。Java 当年主打的核心特征就是：**Write Once Run Anywhere**；通俗来说就是编译器将 Java 文件编译成`.class`，通过 JVM 加载并执行这些`.class`文件；这种执行文件放在所有平台的 JVM 上都拥有相同的产出。

### JVM 架构

![1605925096689](https://github.com/hwangyungping/TalkGo/blob/master/架构师训练营-第一期/images/1605925096689.png)

![1605925096689](.\images\1605925096689.png)





### 性能工具

- JPS：用来输出 JVM 中运行的进程状态信息
- Jstack：用来查看某个 Java 进程内的线程堆栈信息
- Jmap & Jhat：用来查看堆内存使用状况
- Jstat：JVM 统计监测工具
- hprof：展现 CPU 使用率，统计堆内存使用情况
- Jconsole：bin 目录下的工具，支持远程连接，可以查看 JVM 的概述，内存，线程等详细情况

## Java 代码优化

### 线程安全

Java 提供了一系列的关键字和类来保证线程安全：

- `Synchronized`：被 Synchronized 关键字描述的方法或代码块在多线程环境下同一时间只能由一个线程进行访问，保证方法或代码块操作的原子性。
- `Volatile`：相对 Synchronized 来说 Volatile 更加轻量一些，只对基本类型的赋值操作和对象的引用赋值操作有效。
- `java.util.concurrent.atomic`：这个包里包含了一些基于`CAS(CompareAndSwap)`原理实现的类，如`AtomicBoolean`、`AtomicInteger`、`AtomicLong`等，通过使用这些类声明可以保证对其操作具有原子性。
- Lock：是一系列`java.util.concurrent`包内锁的统称，主要有`ReentrantLock`、`ReadLock`、`WriteLock`等锁类，与 Synchronized 关键字不同， Lock 提供了获取锁和释放锁等相关接口，使用上更加灵活，同时也可以做更加复杂的操作。
- `ThreadLocal`：ThreadLocal 提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。

### 内存泄漏

ava 内存泄漏是由于开发人员的错误引起的。

如果程序保留对永远不再使用的对象的引用，这些对象将会占用并耗尽对象。

- 长生命周期对象；
- 静态容器；
- 缓存。

解决办法：创建弱引用对象。

#### 合理使用线程池和对象池

- 复用线程或对象资源，避免在程序的生命周期中创建和删除大量对象。
- 池管理算法（记录哪些对象是空闲的，哪些对象正在使用）。
- 对象内容清除（ThreadLocal 的清空）。

#### 使用合适的 JDK 容器类 (顺序表，链表，Hash)

- LinkList和ArrayList 的区别及适用场景。
- HashMap 的算法实现及应用场景。
- 使用 concurrent 包，ConcurrentHashMap 和 HashMap 的线程安全特性有什么不同？

#### 缩短对象生命周期，加速垃圾回收

- 减少对象驻留内存的时间。
- 在使用时创建对象，用完释放。
- 创建对象的步骤（静态代码段 - 静态成员变量 - 父类构造函数 - 子类构造函数）

### 其他

- 合理使用线程池和对象池
- 使用合适的 JDK 容器类
- 缩短对象生命周期，加速垃圾回收
- 使用 I/O buffer 及 NIO
- 优先使用组合代替继承
- 合理使用单例模式
- 虚拟化所有层次





## 参考

大型网站技术架构-李智慧

MySQL实战45讲

