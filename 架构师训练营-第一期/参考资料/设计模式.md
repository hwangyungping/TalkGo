## 设计模式

每一个模式描述了一个在我们周围**不断重复发生的问题**，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。



### 面向对象设计原则

**依赖倒置原则（DIP）**
• 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
• 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。

**开放封闭原则（OCP）**
• 对扩展开放，对更改封闭。
• 类模块应该是可扩展的，但是不可修改。

**单一职责原则（SRP）**
• 一个类应该仅有一个引起它变化的原因。
• 变化的方向隐含着类的责任。

**Liskov 替换原则（LSP）**
• 子类必须能够替换它们的基类(IS-A)。
• 继承表达类型抽象。

**接口隔离原则（ISP）**
• 不应该强迫客户程序依赖它们不用的方法。
• 接口应该小而完备。

**优先使用对象组合，而不是类继承**
• 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
• 继承在某种程度上破坏了封装性，子类父类耦合度高。
• 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

**封装变化点**
• 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

**针对接口编程，而不是针对实现编程**
• 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
• 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
• 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。



### 将设计原则提升为设计经验

1. 设计习语Design Idioms
   • Design Idioms 描述与特定编程语言相关的低层模式，技巧，惯用法。

2. 设计模式Design Patterns
   • Design Patterns主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。
3. 架构模式Architectural Patterns
   • Architectural Patterns描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。

### GOF-23 模式分类

**从目的来看：**
•创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
•结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
•行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。
**从范围来看：**
•类模式处理类与子类的静态关系。
•对象模式处理对象间的动态关系。

**从封装变化角度对模式分类**

![1604557279372](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604557279372.png)

**组件协作**：
	•Template Method
	•Observer / Event
	•Strategy
**单一职责**：
	•Decorator
	•Bridge
**对象创建**:
	•Factory Method
	•Abstract Factory
	•Prototype
	•Builder
**对象性能**：
	•Singleton
	•Flyweight
**接口隔离**:
	•Façade
	•Proxy
	•Mediator
	•Adapter
**状态变化**：
	•Memento
	•State
**数据结构**：
	•Composite
	•Iterator
	•Chain of Resposibility
**行为变化**：
	•Command
	•Visitor
**领域问题**：
	•Interpreter

### 重构获得模式Refactoring to Patterns

1、面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足**“应对变化，提高复用”**的设计。
2、现代软件设计的特征是“需求的频繁变化”。设计模式的要点是**“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”**.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
3、设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。

### 重构关键技法

1、静态 --> 动态

2、早绑定 --> 晚绑定

3、继承 --> 组合

4、编译时依赖 --> 运行时依赖

5、紧耦合 --> 松耦合

## 23种设计模式

### 组件协作

现代软件专业分工之后的第一个结果是**“框架与应用程序的划分”**，“组件协作”模式通过**晚期绑定**，来实现框架与应用程序之间的**松耦合**，是二者之间协作时常用的模式。

• Template Method
• Observer / Event
• Strategy

#### Template Method

##### 动机（Motivation）

在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。
如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

##### 模式定义

定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。

##### 结构Structure

![1603107277711](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603107277711.png)

##### 要点总结

Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
除了可以灵活应对子步骤的变化外，**“不要调用我，让我来调用你”**的反向控制结构是Template Method的典型应用。
在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。

#### Strategy

##### 动机（Motivation）

在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

##### 模式定义

定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

##### 结构Structure

![1603107969232](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603107969232.png)

##### 要点总结

Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。**含有许多条件判断语句的代码通常都需要Strategy模式**。
如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。



#### Observer / Event

##### 动机（Motivation）

在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，**所有的依赖对象（观察者对象）都将得到通知**。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

##### 模式定义

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

##### 结构Structure

![1603108459516](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603108459516.png)

##### 要点总结

使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。
观察者自己决定是否需要订阅通知，目标对象对此一无所知。
Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。



### 单一职责

在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

• Decorator
• Bridge

#### Decorator

##### 动机（Motivation）

在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？



![1603365151025](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603365151025.png)

![1603365132852](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603365132852.png)



##### 模式定义

动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。

##### 结构Structure

![1603192413856](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603192413856.png)

##### 要点总结

**通过采用组合而非继承的手法**， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。
Decorator模式的目的并非解决“多子类衍生的多继承”问题，**Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义**。



#### Bridge

##### 动机（Motivation）

由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。
如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？

##### 模式定义

将**抽象部分(业务功能)与实现部分(平台实现)分离**，使它们都可以独立地变化。

##### 结构Structure

![1603192941736](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603192941736.png)

##### 要点总结

Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。
Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。
Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。



### 对象创建

通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

• Factory Method
• Abstract Factory
• Prototype
• Builder

#### Factory Method

##### 动机（Motivation）

在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。
如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？

##### 模式定义

定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。

##### 结构Structure

![1603365340287](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603365340287.png)

##### 要点总结

Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
Factory Method模式通过面向对象的手法，**将所要创建的具体对象工作延迟到子类**，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。
Factory Method模式解决“单个对象”的需求变化。**缺点在于要求创建方法/参数相同**。



#### Abstract Factory

##### 动机（Motivation）

在软件系统中，经常面临着**“一系列相互依赖的对象”的创建工作**；同时，由于需求的变化，往往存在更多系列对象的创建工作。
如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？

##### 模式定义

提供一个接口，让该接口负责**创建一系列“相关或者相互依赖的对象”**，无需指定它们具体的类。

##### 结构Structure

![1603365642221](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603365642221.png)



##### 要点总结

如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。
“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。



#### Prototype

##### 动机（Motivation）

在软件系统中，经常面临着**“某些结构复杂的对象”的创建工作**；由于需求的变化，这些对象面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。
如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变？



##### 模式定义

使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。



##### 结构Structure

![1603367059192](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603367059192.png)

##### 要点总结

Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”。
Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。

Prototype模式中Clone方法可以利用某些框架中序列化来实现**深拷贝**。



#### Builder

##### 动机（Motivation）

在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？



##### 模式定义

将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。

##### 结构Structure

![1603366064600](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1603366064600.png)



##### 要点总结

Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。
变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。
在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#) 。



### 对象性能

面向对象很好的解决了“抽象”的问题，但是必不可少地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况下，面向对象所带来的成本必须谨慎处理。

• Singleton
• Flyweight

#### Singleton

##### 动机（Motivation）

![1604556542136](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556542136.png)



##### 模式定义

![1604556561865](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556561865.png)

##### 结构Structure

![1604556573813](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556573813.png)

##### 要点总结

![1604556589938](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556589938.png)

备注：Singleton单例模式的两种实现方法。

#### Flyweight

##### 动机（Motivation）

![1604556640301](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556640301.png)



##### 模式定义

![1604556653944](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556653944.png)

##### 结构Structure

![1604556669263](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556669263.png)

##### 要点总结

![1604556687225](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556687225.png)



### 接口隔离

在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题，甚至根本无法实现。采用添加一层**间接**（稳定）接口来隔离本来相互紧密关联的接口是一种常见的解决方案

• Façade 
• Proxy
• Mediator
• Adapter

#### Façade 门面模式

##### 动机（Motivation）

![1604556752880](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556752880.png)

![1604556766179](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556766179.png)



##### 模式定义

![1604556787129](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556787129.png)

##### 结构Structure

![1604556802873](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556802873.png)

##### 要点总结

![1604556817527](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556817527.png)

#### Proxy 代理模式

##### 动机（Motivation）

![1604556875658](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556875658.png)

##### 模式定义

![1604556889027](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556889027.png)

##### 结构Structure

![1604556900943](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556900943.png)

##### 要点总结

![1604556915328](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556915328.png)

#### Adapter 适配器

##### 动机（Motivation）

![1604556945576](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556945576.png)

##### 模式定义

![1604556959974](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556959974.png)

##### 结构Structure

![1604556972356](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556972356.png)

##### 要点总结

![1604556987446](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604556987446.png)

#### Mediator 中介者

##### 动机（Motivation）

![1604557094428](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604557094428.png)

##### 模式定义

![1604557172097](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604557172097.png)

##### 结构Structure

![1604557184802](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604557184802.png)

##### 要点总结

![1604557204919](C:\Users\0283000056\AppData\Roaming\Typora\typora-user-images\1604557204919.png)

### 状态变化

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效地管理，同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案

• Memento
• State

#### Memento

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结

#### State

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结



### 数据结构

常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案

• Composite
• Iterator
• Chain of Resposibility

#### Composite

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结

#### Iterator

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结

#### Chain of Resposibility

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结

### 行为变化

在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身解耦，从而支持组件行为的变化，实现两者之间的松耦合

• Command
• Visitor

#### Command

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结

#### Visitor

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结



### 领域问题

在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案

• Interpreter 

#### Interpreter 

##### 动机（Motivation）

##### 模式定义

##### 结构Structure

##### 要点总结



| 设计模式                | 定义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Template Method         | 定义一个操作中的算法的骨架（**稳定**），而将一些步骤延迟（**变化**）到子类中。Template Method 使得子类可以不改变（**复用**）一个算法的结构即可**重定义**（override 重写）该算法的某些特定步骤 |
| Strategy                | 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（**变化**）。该模式使得算法可独立于使用它的客户程序（**稳定**）而变化（**扩展、子类化**） |
| Observer/Event          | 定义对象间的一种一对多（**变化**）的依赖关系，以便当一个对象（**Subject**）的状态发生改变时，所有依赖于它的对象都能得到通知并自动更新 |
| Decorator               | 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数） |
| Bridge                  | 将抽象部分（**业务功能**）与实现部分（**平台实现**）分离，使它们都可以独立地变化 |
| Factory Method          | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦；手段：抽象方法）到子类 |
| Abstract Factory        | 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类 |
| Prototype               | 使用**原型实例**指定创建对象的种类，然后通过**拷贝**这些原型来创建新的对象 |
| Builder                 | 将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化） |
| Singleton               | 保证一个类仅有一个实例，并提供一个该实例的全局访问点         |
| Flyweight               | 运用**共享**技术有效地支持**大量**细粒度的对象               |
| Facade                  | 为子系统中的一组接口提供一个一致（**稳定**）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（**复用**）（隔离变化和稳定） |
| Proxy                   | 为其他对象提供一种代理以控制（**隔离** ，即使用接口）对这个对象的访问 |
| Mediator                | 用一个中介对象来封装（**封装变化**）一系列的对象交互。中介者使各对象不需要显式的相互引用（**编译时依赖 -> 运行时依赖** ），从而使其耦合松散（**管理变化**），而且可以独立地改变它们之间的交互 |
| Adapter                 | 将一个类的接口转成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 |
| Memento                 | 在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态 |
| State                   | 允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为 |
| Composite               | 将对象组合成**树形结构**以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有**一致性**（稳定） |
| Iterator                | 提供一种方法顺序访问一个聚合对象中的各个元素，而又**不暴露**（稳定）该对象的内部表示 |
| Chain of Responsibility | 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，知道有一个对象处理它为止 |
| Command                 | 将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作 |
| Visitor                 | 表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（**稳定**）各元素的类的前提下定义（**扩展**）作用于这些元素的新操作（变化） |
| Interpreter             | 给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子 |