# 第 五周课程笔记

**靠山山会倒，靠人人会跑，学会为自己撑伞**



### 分布式缓存架构

#### 什么是缓存Cache

缓存：存储在计算机上的一个原始数据复制集，以便于访问– 维基百科
缓存是介于数据访问者和数据源之间的一种高速存储，当数据需要多次读取的时候，用于加快读取的速度。

#### 缓存常见类型

代理缓存

反向代理缓存

多层反向代理缓存

内容分发网络（CDN）

CDN 同时配置静态文件和动态内容



#### 缓存的关键指标

##### 缓存命中率

• 缓存是否有效依赖于能多少次重用同一个缓存响应业务请求，这个度量指标被称作缓存命中
率。
• 如果查询一个缓存，十次查询九次能够得到正确结果，那么它的命中率是90%。

##### **影响缓存命中率的主要指标**

• 缓存键集合大小

**一定要想办法减少可能的缓存键数量。键数量越少，缓存的效率越高。**

• 缓存可使用内存空间

**物理上能缓存的对象越多，缓存命中率就越高。**

• 缓存对象生存时间

**简单讲，对象缓存的时间越长，缓存对象被重用的可能性就越高。**



#### 通读缓存（read-through）

• 代理缓存，反向代理缓存，CDN 缓存都是通读缓存。
• 通读缓存给客户端返回缓存资源，并在请求未命中缓存时获取实际数据。
• 客户端连接的是通读缓存而不是生成响应的原始服务器。

#### 旁路缓存（cache-aside）

• 对象缓存是一种旁路缓存，旁路缓存通常是一个独立的键值对（key-value）存储。
• 应用代码通常会询问对象缓存需要的对象是否存在，如果存在，它会获取并使用缓存的对象，如果不存在或已过期， 应用会连接主数据源来组装对象，并将其保存回对象缓存中以便将来使用。

#### 本地对象缓存

• 对象直接缓存在应用程序内存中。
• 对象存储在共享内存，同一台机器的多个进程可以访问它们。
• 缓存服务器作为独立应用和应用程序部署在同一个服务器上。



#### 缓存为什么能显著提升性能

• 缓存数据通常来自内存，比磁盘上的数据有更快的访问速度。
• 缓存存储数据的最终结果形态，不需要中间计算，减少CPU 资源的消耗。
• 缓存降低数据库、磁盘、网络的负载压力，使这些I/O 设备获得更好的响应特性。

**缓存是系统性能优化的大杀器**



#### 如何合理使用缓存

使用缓存对提高系统性能有很多好处，但是不合理的使用缓存可能非但不能提高系统的
性能，还会成为系统的累赘，甚至风险。

##### 频繁修改的数据

这种数据如果缓存起来，由于频繁修改，应用还来不及读取就已失效
或更新，徒增系统负担。一般说来，数据的读写比在2:1以上，缓存才有意义。

##### 没有热点的访问

缓存使用内存作为存储，内存资源宝贵而有限，不能将所有数据都缓
存起来，如果应用系统访问数据没有热点，不遵循二八定律，即大部分数据访问不是集
中在小部分数据上，那么缓存就没有意义，因为大部分数据还没有被再次访问就已经被
挤出缓存了。

##### 数据不一致与脏读

一般会对缓存的数据设置失效时间，一旦超过失效时间，就要从数据库中重新加载。

##### 缓存雪崩

缓存是为了提高数据读取性能的，缓存数据丢失或者缓存不可用不会影响到应用程序的处——它可以从数据库直接获取数据。但是随着业务的发展，缓存会承担大部分的数据访问压力，数据库已经习惯了有缓存的日子，所以当缓存服务崩溃的时候，数据库会因为完全不能承受如此大的压力而宕机，进而导致整个网站不可用。这种情况，
被称作缓存雪崩，发生这种故障，甚至不能简单的重启缓存服务器和数据库服务器来恢复网站访问。

##### 缓存预热

缓存中存放的是热点数据，热点数据又是缓存系统利用LRU（最近最久未用）算法对不断访问的数据筛选淘汰出来的，这个过程需要花费较长的时间，在这段时间，系统的性能和数据库负载都不太好，那么最好在缓存系统启动的时候就把热点数据加载好，这个缓存预加载手段叫做缓存预热（warm up）。对于一些元数据如城市地名列表、
类目信息，可以启动时加载数据库中全部数据到缓存进行预热。

##### 缓存穿透

如果不恰当的业务、或者恶意攻击持续高并发的请求某个不存在的数据，因为缓存没有保存该数据，所有的请求都会落到数据库上，会对数据库造成很大的压力，甚至崩溃。一个简单的对策是将不存在的数据也缓存起来（其value 值为null），并设定一个较短的失效时间。



#### Redis VS Memcached

Redis 支持复杂的数据结构
Redis 支持多路复用异步I/O 高性能
Redis 支持主从复制高可用
Redis 原生集群与share nothing 集群模式

**Memcached采用share nothing 集群模式，由客户端执行路由算法，选择服务器节点。服务器集群不感知各节点的存在。**



#### Redis 集群

• Redis 集群预分好16384个桶，当需要在Redis 集群中放置一个key-value 时，根据CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。
• redis-cluster 把所有的物理节点映射到[0-16383]slot上（不一定是平均分配），cluster 负责维护slot 与服务器的映射关系。
• 客户端与Redis 节点直连，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
• 所有的Redis 节点彼此互联。



### 一致性Hash算法原理

#### 一致性Hash性质

平衡性(Balance)

单调性(Monotonicity)

分散性(Spread)

负载(Load)

平滑性(Smoothness)

#### 算法原理

　　一致性哈希算法（Consistent Hashing）最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中被提出。

简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环：

1、如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个空间按顺时针方向组织。0和^32-1在零点中方向重合。

2、将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。

3、接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。



一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。

**一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。**

为了解决这种数据倾斜问题，**一致性哈希算法引入了虚拟节点机制**，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。



### 消息队列与异步架构

#### 同步调用VS 异步调用

通过消息队列构建异步调用架构，包括三个角色：
• 消息生产者
• 消息队列
• 消息消费者

点对点模型、发布订阅模型

#### 消息队列的好处

实现异步处理、提升处理性能
更好的伸缩性
削峰填谷
失败隔离和自我修复
解耦

#### 事件驱动架构EDA



#### 主要MQ 产品比较

• RabbitMQ 的主要特点是性能好，社区活跃，但是RabbitMQ 用Erlang 开发，对不熟悉Erlang 的同学而言不便于二次开发和维护。（49M）
• ActiveMQ 影响比较广泛，可以跨平台，使用Java开发，对Java比较友好。（27M）
• RocketMQ 是阿里推出的一个开源产品，也是使用Java开发，性能比较好，可靠性也比较高。（35M）
• Kafka ，LinkedIn 出品的，Scala 开发，专门针对分布式场景进行了优化，因此分布式的伸缩性会比较好。（63M）

还有Pulsar。



### 负载均衡架构

#### 负载均衡实现方式

##### HTTP 重定向负载均衡

利用HTTP 302重定向消息实现，客户端实现，效率差，需要两次HTTP。基本不采用。

##### DNS 负载均衡

由外部DNS选择服务器，效率高。但应用服务器直接对外提供服务，存在安全隐患。

##### 反向代理负载均衡

HTTP应用层负载均衡，性能差。

##### IP 负载均衡

IP网络层负载均衡，性能较HTTP应用层提升，但响应仍从负载均衡转发，处理压力大

##### 数据链路层负载均衡

通过修改MAC地址，性能提升显著，且后续响应无需经由负载均衡服务器中转



#### 负载均衡算法

• 轮询

所有请求被依次分发到每个应用服务器上，适合于所有服务器硬件都相同的场景。
• 加权轮询

根据应用服务器硬件性能的情况，在轮询的基础上，按照配置的权重将请求分发到每个服务器，高性能的服务器分配更多请求。
• 随机

请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很均衡。如果应用服务器硬件配置不同，也可以很容易的使用加权随机算法。
• 最少连接

记录每个应用服务器正在处理的连接数（请求数），将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。
• 源地址散列

根据请求来源的IP地址进行Hash计算，得到应用服务器，该算法可以保证同一个来源的请求总在同一个服务器上处理，实现会话粘滞。

#### 应用服务器集群的Session 管理

应用服务器的高可用架构设计主要基于服务无状态这一特性，但是事实上，业务总是有状态的。Web 应用中将这些状态信息称作会话（Session），单机情况下，Session 可交给Web 容器管理，在使用负载均衡的集群环境中，Session 管理主要有以下几种手段。

##### Session 复制

应用服务器节点之间需要传递复制Session信息，性能差，处理复制，基本不使用。

##### Session 绑定

通过Session关键字来进行负载均衡分发。

##### 利用Cookie 记录Session

由客户端利用Cookie保存Session信息，但Cookie字段长度受限

##### Session 服务器

单独服务器统一管理Session信息，效率提升。





### **参考**

大型网站技术架构-李智慧

一致性哈希算法原理

https://zhuanlan.zhihu.com/p/78285304

