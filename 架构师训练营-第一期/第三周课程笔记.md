# 第 三周课程笔记

**别人可以替你开车，但不能替你走路。可以替你做事，但不能替你感受。人生的路要靠自己行走，成功要靠自己去争取。天助自助者，成功者自救！**



### 设计模式

**定义：**

每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次
地使用该方案而不必做重复劳动。



**分类：**

创建型（Creational）模式：

将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
• 结构型（Structural）模式：

通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
• 行为型（Behavioral）模式：

通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击



**目标：**

高内聚、低耦合 --- > 应对变化、可复用 --- >基于SOLID原则  --- > 设计模式  --- > 框架与规范

框架如何设计的呢？背后隐含的设计模式。



**学习的关键点**

理解设计模式解决什么问题？属于哪类问题？如何解决的？是学习设计模式的要点。



### 23种设计模式

#### 组件协作：

现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过**晚期绑定**，来实现框架与应用程序之间的**松耦合**，是二者之间协作时常用的模式。

• Template Method
• Observer / Event
• Strategy



#### 单一职责：

在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

• Decorator
• Bridge

#### 对象创建:

通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

• Factory Method
• Abstract Factory
• Prototype
• Builder

#### 对象性能：

面向对象很好的解决了“抽象”的问题，但是必不可少地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况下，面向对象所带来的成本必须谨慎处理。

• Singleton
• Flyweight



备注：Singleton单例模式的两种实现方法。



#### 接口隔离:

在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题，甚至根本无法实现。采用添加一层**间接**（稳定）接口来隔离本来相互紧密关联的接口是一种常见的解决方案

• Façade 
• Proxy
• Mediator
• Adapter

#### 状态变化：

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效地管理，同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案

• Memento
• State

####  数据结构：

常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案

• Composite
• Iterator
• Chain of Resposibility

####  行为变化：

在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身解耦，从而支持组件行为的变化，实现两者之间的松耦合

• Command
• Visitor

####  领域问题：

在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案

• Interpreter 



| 设计模式                | 定义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Template Method         | 定义一个操作中的算法的骨架（**稳定**），而将一些步骤延迟（**变化**）到子类中。Template Method 使得子类可以不改变（**复用**）一个算法的结构即可**重定义**（override 重写）该算法的某些特定步骤 |
| Strategy                | 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（**变化**）。该模式使得算法可独立于使用它的客户程序（**稳定**）而变化（**扩展、子类化**） |
| Observer/Event          | 定义对象间的一种一对多（**变化**）的依赖关系，以便当一个对象（**Subject**）的状态发生改变时，所有依赖于它的对象都能得到通知并自动更新 |
| Decorator               | 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数） |
| Bridge                  | 将抽象部分（**业务功能**）与实现部分（**平台实现**）分离，使它们都可以独立地变化 |
| Factory Method          | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦；手段：抽象方法）到子类 |
| Abstract Factory        | 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类 |
| Prototype               | 使用**原型实例**指定创建对象的种类，然后通过**拷贝**这些原型来创建新的对象 |
| Builder                 | 将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化） |
| Singleton               | 保证一个类仅有一个实例，并提供一个该实例的全局访问点         |
| Flyweight               | 运用**共享**技术有效地支持**大量**细粒度的对象               |
| Facade                  | 为子系统中的一组接口提供一个一致（**稳定**）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（**复用**）（隔离变化和稳定） |
| Proxy                   | 为其他对象提供一种代理以控制（**隔离** ，即使用接口）对这个对象的访问 |
| Mediator                | 用一个中介对象来封装（**封装变化**）一系列的对象交互。中介者使各对象不需要显式的相互引用（**编译时依赖 -> 运行时依赖** ），从而使其耦合松散（**管理变化**），而且可以独立地改变它们之间的交互 |
| Adapter                 | 将一个类的接口转成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 |
| Memento                 | 在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态 |
| State                   | 允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为 |
| Composite               | 将对象组合成**树形结构**以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有**一致性**（稳定） |
| Iterator                | 提供一种方法顺序访问一个聚合对象中的各个元素，而又**不暴露**（稳定）该对象的内部表示 |
| Chain of Responsibility | 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，知道有一个对象处理它为止 |
| Command                 | 将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作 |
| Visitor                 | 表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（**稳定**）各元素的类的前提下定义（**扩展**）作用于这些元素的新操作（变化） |
| Interpreter             | 给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子 |

### 参考

C++设计模式 李建忠

极客时间 设计模式之美



