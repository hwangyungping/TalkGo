# 第八周课程笔记

**学习是不可能速成的。学习是一件“逆人性”的事，就像锻炼身体一样，需要人持续付出，会让人感到痛苦，并随时想找理由放弃。**



## 数据结构与算法

### 空间复杂度和时间复杂度

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

时间复杂度分析
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )。



### 数据结构

- 数组：

  数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

  特点：线性表、连续内存空间。支持“随机访问”。因此元素的访问时间复杂度是 O(1)，但是插入数据和删除数据操作复杂，还有越界的风险。

- 链表：

  也是线性表，但在内存中是分散的，访问时间复杂度是 O(n)，插入数据和删除数据操作简便，而且链表长度几乎没有限制（不超过内存空间的情况下）

- Hash 表：

  哈希表是根据键（Key）而直接访问在内存储存位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，从而加速了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

  常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。

- 栈：

  也是一种线性表结构，实现上可以是数组也可以是链表。它规定了数据存取的规则后进先出——被插入的数据会放到线性表头部，读取时也是从线性表的头部开始。

- 队列：

  队列的实现结构和栈一样，但是它的存取规则是先进先出——被插入的数据被放到线性表尾部，而读取的时候总是从线性表的头部开始。

- 树：

  是一种抽象数据类型，用来模拟具有树状结构性质的数据集合。它是由 n 个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

  - 二叉查找树（BST）：运用了二分查找的思想，查找所需的最大次数等于树的高度；但是有缺点：可能会成为单边的二叉树，搜索时间复杂度为 O(n)
  - 平衡二叉树（AVL）：是对 BST 的改进，任一节点对应的两棵子树的最大高度差为 1；但是为了自平衡，插入数据时需要不断自旋调整，效率较低
  - 红黑树：上面两数的 trade-off，自平衡的二叉查找树，能保证根到叶子的最长路劲不会超过最短路径的 2 倍；又能在插入数据时，保证最多只需 3 次旋转即能平衡
  - B+树：通常用于数据库和操作系统的文件系统中。B+树中的节点通常被表示为一组有序的元素和子指针；因此它是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。

- 跳表：

  是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。插入、删除操作的时间复杂度也是 O(logn)。

### 算法

- 分治算法（递归实现）：

  是指一种通过重复将问题分解为同类的子问题而解决问题的方法。

  分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

  **分治算法是一种处理问题的思想，递归是一种编程技巧**。

  实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：

  分解：将原问题分解成一系列子问题；

  解决：递归地求解各个子问题，若子问题足够小，则直接求解；

  合并：将子问题的结果合并成原问题。

  分治算法能解决的问题，一般需要满足下面这几个条件：

  1、原问题与分解成的小问题具有相同的模式；

  2、原问题分解成的子问题可以独立求解，子问题之间没有相关性；

  3、具有分解终止条件，也就是说，当问题足够小时，可以直接求解；

  4、可以将子问题合并成原问题。

  

- 回溯算法（递归实现）

  回溯算法大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。

- 贪心算法：

  是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。

  对于大部分的问题，贪心法通常都不能找出最佳解，因为他们一般没有测试所有可能的解。贪心法容易过早做决定，因而没法达到最佳解。

  贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。

- 动态规划：

  通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。著名的动态规划算法有：最长公共子序列、Floyd-Warshall 算法、Viterbi 算法等等。

- 遗传算法：

  最初是借鉴了进化生物学中的一些现象而发展起来的搜索算法，这些现象包括遗传、突变、自然选择以及杂交等等。遗传算法通常实现方式为一种计算机模拟。对于一个最优化问题，一定数量的候选解（称为个体）可抽象表示为染色体，使种群向更好的解进化。遗传算法擅长解决的问题是全局最优化问题。



## 多路复用IO与NIO

### IO模型

1、同步阻塞IO（Blocking IO）：即传统的IO模型。

2、同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。

3、多路复用IO（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。

4、异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。





## 参考

大型网站技术架构-李智慧

数据结构与算法之美 王争

