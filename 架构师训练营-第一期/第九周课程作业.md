# 第 九周课程作业



### 题目一

请简述 JVM 垃圾回收原理

JVM 垃圾回收

目的：将 JVM 堆中的已经不再被使用的对象清理掉，释放宝贵的内存资源。

JVM 通过一种可达性分析算法进行垃圾对象的标识。具体过程是：

1. 从线程栈帧中的局部变量，或者方法区的静态变量出发，将这个变量引用的对象进行标记；
2. 然后看这些被标记的对象是否引用了其它对象，继续进行标记；
3. 所有被标记过的对象都是被使用的对象，而那些没有被标记的对象就是可回收的垃圾对象了。

进行完标记以后，JVM 就会对垃圾对象占用的内存进行回收，回收主要有三种方法：

1. 清理：将垃圾对象占据的内存清理掉，其实 JVM 并不会真的将这些垃圾内存进行清理，而是将这些垃圾对象占用的内存空间标记为空闲，记录在一个空闲的列表里，当应用程序需要创建新的对象的时候，就从空闲列表中找一段空闲内存分配给这个对象。
2. 压缩：从堆空间的头部开始，将存活的对象拷贝到一段连续的内存空间中，那么其余的空间就是连续的空闲空间。
3. 复制：将堆空间分成两部分，只在其中一部分创建对象，当这个部分空间用完的时候，将标记过的可用对象复制到另一个空间中。

**JVM 分代垃圾回收**

![1605925523146](https://github.com/hwangyungping/TalkGo/blob/master/架构师训练营-第一期/images/1605925523146.png)

![1605925523146](.\images\1605925523146.png)

1. 创建新对象在Eden区，当Eden区满了以后，就会进行Young GC，把在用的对象copy到From区；
2. 当Eden区再次满了以后，再次进行YoungGC，把Eden区和From区的在用对象，copy到To区；
3. 当多次Eden发送YoungGC，把一些还用的对象放到老年代；
4. 当老年代满了以后，就会进行Full GC。这是要应用线程都要暂停，进行Full GC。

**JVM垃圾回收器算法**

1. 串行回收器：当JVM空间满了以后，stop-the-world 停止所有应用程序的线程，进行垃圾回收。（以前的都是单CPU）
2. 并行回收器：多CPU时代，当JVM空间满了以后，stop-the-world 多线程进行垃圾回收。（大数据用这种方式，效率比较高）
3. 并发回收器CMS：初始化标记静态变量等以及引用的对象 > 并发标记 > 重标记(永远表不完对象，因为对象一直在创建。所以这个阶段也会stop-the-world) > 并发清理。（早期Web应用都是用这种方式，但是浪费计算资源比较多。）
4. G1回收器(主流)：效率更高，下面详细介绍。每次stop-the-world的时候，只会清理一部分区域，控制范围更小一些。

![1605925538797](https://github.com/hwangyungping/TalkGo/blob/master/架构师训练营-第一期/images/1605925538797.png)

![1605925538797](.\images\1605925538797.png)



### 题目二



设计一个秒杀系统，主要的挑战和问题有哪些？核心的架构方案或者思路有哪些？

**挑战和问题**

秒杀系统的核心挑战就是**高并发**：在极短时间内有大量请求达到，可能导致全站奔溃。其他的问题还包括：

- 超卖
- 恶意请求
- 链接暴露

**秒杀系统：设计原则**

**静态化**

- 采用 JS 自动更新技术将动态页面转化为静态页面。（为运营人员开发，上传秒杀商品信息，转换为静态页面的运营系统。）

**并发控制，防秒杀器**

- 设置阀门，只放最前面的一部分人进入秒杀系统。

**简化流程**

- 砍掉不重用的分支流程，如下单页面的所有数据库查询。
- 以下单成功作为秒杀成功标志。支付流程只要在 1 天内完成即可。

**前端优化**

- ##### 采用 YSLOW 原则提升页面的响应速度。